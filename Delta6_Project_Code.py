# -*- coding: utf-8 -*-
"""Delta6_New.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VluZsDpeiXfJodoauBIEVw2QbZEl84vx
"""

# ============================================================
# Traffic-Aware Drone Route Optimization
# Directional Routes with Hill Climbing
# ============================================================

import numpy as np
import random
import matplotlib.pyplot as plt

# ----------------------------
# 1. Environment & nodes
# ----------------------------
np.random.seed(46656)

NUM_NODES = 120 #no. of destinations to be covered
BASE_SPEED = 50.0 #Speed limit
START_NODE = 0  # N0 is start and end
eps = 0.02

coords = np.random.rand(NUM_NODES, 2) * 100
traffic = np.random.uniform(1.0, 3.0, NUM_NODES)

node_labels = [f"N{i}" for i in range(NUM_NODES)]

# ----------------------------
# 2. Travel time objective
# ----------------------------
def route_travel_time(route):
    total = 0
    for i in range(len(route)):
        a = route[i]
        b = route[(i + 1) % len(route)]
        d = np.linalg.norm(coords[a] - coords[b])
        congestion = (traffic[a] + traffic[b]) / 2
        total += d * congestion / BASE_SPEED
    return total

# ----------------------------
# 3. Neighbor generation
# ----------------------------
def neighbor(route):
    r = route.copy()
    i, j = random.sample(range(1, len(route)), 2)
    r[i], r[j] = r[j], r[i]
    return r

# ----------------------------
# 4. Hill Climbing algorithms
# ----------------------------
def deterministic_hc(init, iters=400):
    curr = init
    curr_cost = route_travel_time(curr)
    for _ in range(iters):
        neighbors = [neighbor(curr) for _ in range(40)]
        best = min(neighbors, key=route_travel_time)
        best_cost = route_travel_time(best)
        if best_cost < curr_cost:
            curr, curr_cost = best, best_cost
        else:
            break
    return curr, curr_cost

def stochastic_hc(init, iters=400):
    curr = init
    curr_cost = route_travel_time(curr)
    for _ in range(iters):
        n = neighbor(curr)
        n_cost = route_travel_time(n)
        if n_cost < curr_cost:
            curr, curr_cost = n, n_cost
    return curr, curr_cost

# ----------------------------
# 5. Run multiple experiments
# ----------------------------
def run_experiments(algorithm, runs=15):
    results = []
    for _ in range(runs):
        route = list(range(NUM_NODES))
        random.shuffle(route[1:])  # keep N0 fixed
        best, cost = algorithm(route)
        results.append((best, cost))
    return results

det_routes = run_experiments(deterministic_hc)
sto_routes = run_experiments(stochastic_hc)

best_det = min(det_routes, key=lambda x: x[1])
best_sto = min(sto_routes, key=lambda x: x[1])

# ----------------------------
# 6. Plot utilities
# ----------------------------
def plot_nodes():
    for i, (x, y) in enumerate(coords):
        plt.scatter(x, y, color='black', zorder=3)
        plt.text(x + 1, y + 1, node_labels[i], fontsize=9)
    plt.scatter(coords[START_NODE,0], coords[START_NODE,1],
                color='green', s=120, label="Start/End (N0)", zorder=4)

def draw_arrow(a, b, congestion):
    norm_c = (congestion - 1) / 2
    dx = coords[b,0] - coords[a,0]
    dy = coords[b,1] - coords[a,1]

    plt.arrow(
        coords[a,0], coords[a,1],
        dx, dy,
        length_includes_head=True,
        head_width=2,
        head_length=3,
        linewidth=1 + congestion,
        color=plt.cm.cool(norm_c),
        alpha=0.9,
        zorder=2
    )

def plot_all_routes(routes, title):
    plt.figure(figsize=(7,7))
    for r, _ in routes:
        for i in range(len(r)):
            a = r[i]
            b = r[(i + 1) % len(r)]
            plt.plot(
                [coords[a,0], coords[b,0]],
                [coords[a,1], coords[b,1]],
                color='gray',
                alpha=0.25
            )
    plot_nodes()
    plt.title(title)
    plt.legend()
    plt.show()

def plot_best_route(route, title):
    plt.figure(figsize=(7,7))
    for i in range(len(route)):
        a = route[i]
        b = route[(i + 1) % len(route)]
        congestion = (traffic[a] + traffic[b]) / 2
        draw_arrow(a, b, congestion)

    plot_nodes()

    sm = plt.cm.ScalarMappable(
        cmap='cool',
        norm=plt.Normalize(1, 3)
    )
    plt.colorbar(sm, ax=plt.gca(), label="Edge Traffic Congestion (Low â†’ High)") # Added ax=plt.gca()
    plt.title(title)
    plt.show()

# ----------------------------
# 7. Visualizations
# ----------------------------
print("DELTA6 AI PROJECT: DRONE DELIVERY ROUTE OPTIMISATION")
print("Barshneyo Chakraborty B2530075")
print("Sagnik Chandra B2530084")
print("Tamojit Mondal B2530091")
plot_all_routes(det_routes,
                "Deterministic Hill Climbing: Collective Routes")

plot_all_routes(sto_routes,
                "Stochastic Hill Climbing: Collective Routes")

plot_best_route(best_det[0],
                f"Best Deterministic Route\nTravel Time = {best_det[1]:.2f} hrs")

plot_best_route(best_sto[0],
                f"Best Stochastic Route\nTravel Time = {best_sto[1]:.2f} hrs")

# ----------------------------
# 8. Verdict
# ----------------------------
print("Best Deterministic Travel Time:", best_det[1])
print("Best Stochastic Travel Time:", best_sto[1])

if best_det[1] < best_sto[1]:
    print("\nFASTEST ROUTE FOUND BY: Deterministic Hill Climbing")
elif best_det[1] == best_sto[1]:
    print("\nBoth Deterministic and Stochastic Hill Climbing algorithms give the same travel time. We can use either.")
elif np.abs(best_det[1] - best_sto[1]) < eps:
    print("\n Since difference in travel time between deterministic and stochastic hill climbing algorithms, we can use one with the least number heavily congested edges or with the most number of lightly/not congested edges")
else:
    print("\nFASTEST ROUTE FOUND BY: Stochastic Hill Climbing")
print("Colour grading of edge traffic congestion : 3 - heavily congested, 1 - lightly/not congested")



# ---------------------------
# 9. Comparison Plot of convergence of both algorithms
# ---------------------------
def deterministic_hc_with_history(init, iters=400):
    curr = init
    curr_cost = route_travel_time(curr)
    history = [curr_cost]

    for _ in range(iters):
        neighbors = [neighbor(curr) for _ in range(40)]
        best = min(neighbors, key=route_travel_time)
        best_cost = route_travel_time(best)

        if best_cost < curr_cost:
            curr, curr_cost = best, best_cost
        else:
            break

        history.append(curr_cost)

    return curr, curr_cost, history


def stochastic_hc_with_history(init, iters=400):
    curr = init
    curr_cost = route_travel_time(curr)
    history = [curr_cost]

    for _ in range(iters):
        n = neighbor(curr)
        n_cost = route_travel_time(n)

        if n_cost < curr_cost:
            curr, curr_cost = n, n_cost

        history.append(curr_cost)

    return curr, curr_cost, history


def plot_convergence_comparison(det_history, sto_history):
    plt.figure(figsize=(7, 5))

    plt.plot(det_history, label="Deterministic Hill Climbing", linewidth=2)
    plt.plot(sto_history, label="Stochastic Hill Climbing", linewidth=2)

    plt.xlabel("Iteration")
    plt.ylabel("Best Travel Time (hours)")
    plt.title("Convergence Rate Comparison")
    plt.legend()
    plt.grid(True)
    plt.show()

init_route = list(range(NUM_NODES))
random.shuffle(init_route[1:])  # keep N0 fixed

_, _, det_history = deterministic_hc_with_history(init_route, iters=400)
_, _, sto_history = stochastic_hc_with_history(init_route, iters=400)

plot_convergence_comparison(det_history, sto_history)